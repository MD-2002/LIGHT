//////////////////////PONTO NO CENTRO

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Introduction to HTML</title>
  </head>
  <body>
    <canvas
      id="mycanv"
      width="600"
      height="400"
      style="background-color: rgb(29, 181, 47); border: 2px solid black"
    ></canvas>

    <script src="main.js"></script>
  </body>
</html>

    const canvas = document.querySelector(`canvas`);
    const webgl = canvas.getContext(`webgl`);
    const vsSource =`  
        void main() { gl_Position = vec4(0,0,0,0.5);
        gl_PointSize=50.0;
    }`
    const fsSource = `
    void main() { gl_FragColor = vec4(1.0,0,0,1.0); }`;
    const vertexShader = webgl.createShader(webgl.VERTEX_SHADER);
    webgl.shaderSource(vertexShader, vsSource ); 
    webgl.compileShader(vertexShader);
   
    const fragmentShader = webgl.createShader(webgl.FRAGMENT_SHADER);
    webgl.shaderSource(fragmentShader, fsSource);
    webgl.compileShader(fragmentShader);
    
    const program = webgl.createProgram();
    webgl.attachShader(program, vertexShader);
    webgl.attachShader(program, fragmentShader);
    webgl.linkProgram(program);
    webgl.useProgram(program);
    webgl.drawArrays(webgl.POINTS, 0, 1);


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

TRIANGLE

    const canvas = document.querySelector(`canvas`);
    const webgl = canvas.getContext(`webgl`);
    if(!webgl){ throw new Error("WebGL not available/supported");}
    webgl.clearColor(1.0,1.0,0,1);
    webgl.clear(webgl.COLOR_BUFFER_BIT);
    const vertices = new Float32Array([
        0.0, 0.5, 0.0,
        -0.5,-0.5,0.0,
        0.0,-0.5, 0.0
        
    ]);
    const buffer = webgl.createBuffer();
    webgl.bindBuffer(webgl.ARRAY_BUFFER, buffer);
    webgl.bufferData(webgl.ARRAY_BUFFER, vertices, webgl.STATIC_DRAW);
    const vsSource =`     
    attribute vec2 pos;
    void main() { gl_Position = vec4(pos,0,1); }`
    const fsSource = `
    void main() { gl_FragColor = vec4(1.0,0,0,1.0); }`;
    const vertexShader = webgl.createShader(webgl.VERTEX_SHADER);
    webgl.shaderSource(vertexShader, vsSource ); 
    webgl.compileShader(vertexShader);
   
    const fragmentShader = webgl.createShader(webgl.FRAGMENT_SHADER);
    webgl.shaderSource(fragmentShader, fsSource);
    webgl.compileShader(fragmentShader);
   
    const program = webgl.createProgram();
    webgl.attachShader(program, vertexShader);
    webgl.attachShader(program, fragmentShader);
    webgl.linkProgram(program);
    
    const positionLocation = webgl.getAttribLocation(program, `pos`);
    webgl.enableVertexAttribArray(positionLocation);
    webgl.vertexAttribPointer(positionLocation, 2, webgl.FLOAT, false, 0, 0);
    //webgl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    webgl.useProgram(program);
    webgl.drawArrays(webgl.TRIANGLES, 0, 3);    
    //webgl.drawArrays(webgl.TRIANGLE_FAN, 0, 7);    
    //webgl.drawArrays(webgl.TRIANGLE_STRIP, 0, 7);
 

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.

CIRCLE


const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');

if (!gl) {
    throw new Error('WebGL not supported');
}
const numSegments = 360; // Number of segments to approximate the circle

const vertexData = new Float32Array((numSegments + 2) * 3);

// Center of the circle
vertexData[0] = 0;
vertexData[1] = 0;
vertexData[2] = 0;

// Points of the circle
for (let i = 0; i <= numSegments; i++) {
    const theta = (i / numSegments) * 2 * Math.PI;
    const x = 0.5 * Math.cos(theta);
    const y = 0.5 * Math.sin(theta);
    vertexData[(i + 1) * 3] = x;
    vertexData[(i + 1) * 3 + 1] = y;
    vertexData[(i + 1) * 3 + 2] = 0;
}

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, `
attribute vec3 position;

void main() {
    gl_Position = vec4(position, 0.9);
}
`);
gl.compileShader(vertexShader);

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, `
void main() {
    gl_FragColor = vec4(1, 1, 0, 1);
}
`);
gl.compileShader(fragmentShader);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

const positionLocation = gl.getAttribLocation(program, 'position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

gl.useProgram(program);
gl.drawArrays(gl.TRIANGLE_FAN, 0, numSegments + 2);

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

PENTAGON


const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');

if (!gl) {
    throw new Error('WebGL not supported');
}

const vertexData =new Float32Array([
    0, 0.35, 0,
   -0.35, 0.2, 0,
   -0.2, -0.2, 0,
    0.2, -0.2, 0,
    0.35, 0.2, 0
]);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, `
attribute vec3 position;
void main() {
    gl_Position = vec4(position, 0.8);
}
`);
gl.compileShader(vertexShader);

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, `
void main() {
    gl_FragColor = vec4(0, 1, 1, 1);
}
`);
gl.compileShader(fragmentShader);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

const positionLocation = gl.getAttribLocation(program, 'position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

gl.useProgram(program);
gl.enable(gl.DEPTH_TEST);

gl.drawArrays(gl.TRIANGLE_FAN, 0, 5);


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

RECTANGLE LOSANGE

const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');

if (!gl) {
    throw new Error('WebGL not supported');
}

const vertexData = new Float32Array([
    // Vertices of the rectangle (lozenge)
    0, 0.5, 0,
    -0.5, 0, 0,
    0, -0.5, 0,
    0.5, 0, 0,
]);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, `
attribute vec3 position;

void main() {
    gl_Position = vec4(position, 0.8);
}
`);
gl.compileShader(vertexShader);

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, `
void main() {
    gl_FragColor = vec4(2, 1, 2, 1);
}
`);
gl.compileShader(fragmentShader);
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

const positionLocation = gl.getAttribLocation(program, 'position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
gl.useProgram(program);
gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


PENTAGON RODANDO E A BATER NOS CANTOS COM BOTAO DE COMECAR E PARAR.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Petagon Fernando Sapalo</title>
</head>

<body>
    <h1>Fernando Sapalo</h1>
    <canvas 
    width="600"
    height="400"
    style="background-color: rgb(34, 165, 53); border: 2px solid black"></canvas>
    <script src="main.js"></script>
</body>
</html>




const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');

if(!gl){
    throw new Error('Webgl is not available !');
}

const vertexData =new Float32Array([
    0, 0.50, 0,
   -0.50, 0.2, 0,
   -0.2, -0.2, 0,
    0.2, -0.2, 0, 
    0.50, 0.2, 0,
]);

const buffer=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexData,gl.STATIC_DRAW);

const vertexShader=gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader,`
attribute vec3 position;
uniform float rotation;
uniform vec2 translation;
void main(){
    float cosR = cos(rotation);
    float sinR = sin(rotation);
    vec2 rotatedPosition = vec2(
        cosR * position.x - sinR * position.y,
        sinR * position.x + cosR * position.y
    );
    gl_Position = vec4(rotatedPosition.x + translation.x, rotatedPosition.y + translation.y, position.z, 1);
}
`);
gl.compileShader(vertexShader);

const fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader,`
void main(){
    gl_FragColor=vec4(0, 1, 1, 1);
}
`);
gl.compileShader(fragmentShader);

const program=gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

const positionLocation = gl.getAttribLocation(program, 'position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 3 , gl.FLOAT , false , 0 , 0); 

gl.useProgram(program);
gl.enable(gl.DEPTH_TEST);

const rotationLocation = gl.getUniformLocation(program, 'rotation');
const translationLocation = gl.getUniformLocation(program, 'translation');
let rotation = 0;
let x =-0.45;
let y =0;
let directionX=1;
let directionY=0;
const speed=0.050;

let animationId = null;

function animate(){
    rotation += 1;
    x += directionX * speed;
    y += directionY * speed;
 
    if(x>=0.47 && directionX>0){
        directionX=0;
        directionY=1;
    }else if(y>=0.45 && directionY>0){
        directionX=-1;
        directionY=0;
    }else if(x<=-0.47 && directionX<0){
        directionX=0;
        directionY=-1;
    }else if(y<=-0.76 && directionY<0){
        directionX=1;
        directionY=0;
    }

    gl.uniform1f(rotationLocation, rotation);
    gl.uniform2f(translationLocation , x , y );
    gl.drawArrays(gl.TRIANGLE_FAN,0,5);
    animationId = requestAnimationFrame(animate);
}

const startButton = document.createElement('button');
startButton.textContent = 'Start';
startButton.addEventListener('click', () => {
    if (!animationId) {
        animate();
    }
});

const stopButton = document.createElement('button');
stopButton.textContent = 'Stop';
stopButton.addEventListener('click', () => {
    if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
    }
});
document.body.appendChild(startButton);
document.body.appendChild(stopButton);


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.

REGANGLE LOSANGE BATENDO NOS CANTOS


const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');

if(!gl){
    throw new Error('Webgl is not available !');
}

const vertexData = new Float32Array([
    // Vertices of the rectangle (lozenge)
    0, 0.25, 0,
    -0.25, 0, 0,
    0, -0.25, 0,
    0.25, 0, 0,
]);

const buffer=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexData,gl.STATIC_DRAW);

const vertexShader=gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader,`
attribute vec3 position;
uniform vec2 translation;
void main(){
    gl_Position=vec4(position.x+translation.x, position.y+translation.y, position.z,1);
}
`);
gl.compileShader(vertexShader);

const fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader,`
void main(){
    gl_FragColor=vec4(2, 1, 2, 1);
}
`);
gl.compileShader(fragmentShader);

const program=gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

const positionLocation = gl.getAttribLocation(program, 'position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 3 , gl.FLOAT , false , 0 , 0); 

gl.useProgram(program);
gl.enable(gl.DEPTH_TEST);

const translationLocation = gl.getUniformLocation(program, 'translation');
const speed=0.050;

let x =-0.75;
let y =0;
let directionX=1;
let directionY=0;

function animate(){
    x += directionX * speed;
    y += directionY * speed;

    if(x>=0.75 && directionX>0){
        directionX=0;
        directionY=1;
    }else if(y>=0.75 && directionY>0){
        directionX=-1;
        directionY=0;
    }else if(x<=-0.75 && directionX<0){
        directionX=0;
        directionY=-1;
    }else if(y<=-0.75 && directionY<0){
        directionX=1;
        directionY=0;
    }

    gl.uniform2f(translationLocation , x , y );
    gl.drawArrays(gl.TRIANGLE_FAN,0,4);
    requestAnimationFrame(animate);
}
animate();

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.>.


DUAS FIGURAS RODANDO E A BATER NOS CANTOS COM BOTAO DE COMECO E PARAGEM


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polygon Fernando Sapalo</title>
</head>

<body>
    <h1>Fernando Sapalo</h1>
    <canvas 
    width="600"
    height="400"
    style="background-color: rgb(34, 165, 53); border: 2px solid black"></canvas>
    <script src="main.js"></script>
</body>
</html>



const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');

if(!gl){
    throw new Error('Webgl is not available !');
}

const vertexData =new Float32Array([
    0, 0.25, 0,
   -0.25, 0.1, 0,
   -0.1, -0.1, 0,
    0.1, -0.1, 0, 
    0.25, 0.1, 0,
]);

const vertexData2 = new Float32Array([
    // Vertices of the rectangle (lozenge)
    0, 0.25, 0,
    -0.25, 0, 0,
    0, -0.25, 0,
    0.25, 0, 0,
]);


const buffer=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexData,gl.STATIC_DRAW);

const buffer2=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buffer2);
gl.bufferData(gl.ARRAY_BUFFER, vertexData,gl.STATIC_DRAW);

const vertexShader=gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader,`
attribute vec3 position;
uniform float rotation;
uniform vec2 translation;
void main(){
    float cosR = cos(rotation);
    float sinR = sin(rotation);
    vec2 rotatedPosition = vec2(
        cosR * position.x - sinR * position.y,
        sinR * position.x + cosR * position.y
    );
    gl_Position = vec4(rotatedPosition.x + translation.x, rotatedPosition.y + translation.y, position.z, 1);
}
`);
gl.compileShader(vertexShader);

const fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader,`
void main(){
    gl_FragColor=vec4(0, 1, 1, 1);
}
`);
gl.compileShader(fragmentShader);

const fragmentShader2=gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader2,`
void main(){
    gl_FragColor=vec4(1, 0, 0, 1);
}
`);
gl.compileShader(fragmentShader2);

const program=gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

const program2=gl.createProgram();
gl.attachShader(program2, vertexShader);
gl.attachShader(program2, fragmentShader2);
gl.linkProgram(program2);

const positionLocation = gl.getAttribLocation(program, 'position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 3 , gl.FLOAT , false , 0 , 0); 

const positionLocation2 = gl.getAttribLocation(program2, 'position');
gl.enableVertexAttribArray(positionLocation2);
gl.vertexAttribPointer(positionLocation2, 3 , gl.FLOAT , false , 0 , 0); 


gl.useProgram(program);
gl.enable(gl.DEPTH_TEST);

const rotationLocation = gl.getUniformLocation(program, 'rotation');
const translationLocation = gl.getUniformLocation(program, 'translation');
let rotation = 0;
let x =-0.20;
let y =0;
let directionX=1;
let directionY=0;
const speed=0.050;

let animationId = null;

const rotationLocation2 = gl.getUniformLocation(program2, 'rotation');
const translationLocation2 = gl.getUniformLocation(program2, 'translation');
let rotation2 = 0;
let x2 =-0.45;
let y2 =0;
let directionX2=1;
let directionY2=0;
const speed2=0.060;

function animate(){
    rotation += 2;
    x += directionX * speed;
    y += directionY * speed;

    rotation2 += 2;
    x2 += directionX2 * speed2;
    y2 += directionY2 * speed2;
 
    if(x>=0.75 && directionX>0){
        directionX=0;
        directionY=1;
    }else if(y>=0.75 && directionY>0){
        directionX=-1;
        directionY=0;
    }else if(x<=-0.75 && directionX<0){
        directionX=0;
        directionY=-1;
    }else if(y<=-0.75 && directionY<0){
        directionX=1;
        directionY=0;
    }

    if(x2>=0.70 && directionX2>0){
        directionX2=0;
        directionY2=1;
    }else if(y2>=0.0 && directionY2>0){
        directionX2=-1;
        directionY2=0;
    }else if(x2<=-0.60 && directionX2<0){
        directionX2=0;
        directionY2=-1;
    }else if(y2<=-0.60 && directionY2<0){
        directionX2=1;
        directionY2=0;
    }

    gl.useProgram(program2);
    gl.uniform1f(rotationLocation2, rotation2);
    gl.uniform2f(translationLocation2, x2, y2);
    gl.drawArrays(gl.TRIANGLE_FAN,0,4);

    gl.useProgram(program);
    gl.uniform1f(rotationLocation, rotation);
    gl.uniform2f(translationLocation , x , y );
    gl.drawArrays(gl.TRIANGLE_FAN,0,5);
    animationId = requestAnimationFrame(animate);
}

const startButton = document.createElement('button');
startButton.textContent = 'Start';
startButton.addEventListener('click', () => {
    if (!animationId) {
        animate();
    }
});

const stopButton = document.createElement('button');
stopButton.textContent = 'Stop';
stopButton.addEventListener('click', () => {
    if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
    }
});

document.body.appendChild(startButton);
document.body.appendChild(stopButton);



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


RED TRIANGLE MOVING AROUND THE CANVAS ALONG THE X AND Y AXIS WHILE ROTATING, GREEN RECTANGLE SHAKING AND BLUE RECTANGLE BOUNCING IN THE Y AXIS. POR MARCOS.




<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROTATION</title>
    <link rel="stylesheet" href="main.css">
</head>
<body>
    <h1>RED TRIANGLE MOVING AROUND THE CANVAS ALONG THE X AND Y AXIS WHILE ROTATING, GREEN RECTANGLE SHAKING AND BLUE RECTANGLE BOUNCING IN THE Y AXIS</h1>
    <button id="button-switcher" onclick="st();"  class="button">
    START/STOP </button>
    <button id="button-switcher" onclick="st_1()" class="button">Triangle_STO/START</button>
    <button id="button-switcher" onclick="st_2()" class="button">Green_Rec_STO/START</button>
    <button id="button-switcher" onclick="st_3()" class="button">Blue_Rec_STO/START</button>
    <canvas ></canvas><br/>
    <script src="main.js"></script>
</body>
</html>

///// CSS

canvas{
    width:650px; 
    height:300px;
    background-color:rgb(56, 55, 81); 
    border: 1px solid black;
    align-content: center;
}

button{
    font-style: italic;
    background-color: brown;
    font-size: large;
   
}
body{
    margin: 1px;
}


/////

const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');

if(!gl){
    throw new Error('Webgl is not available !');
}

const vertexData= new Float32Array([
    0,0.13,0,
    0.13,0,0,
    -0.13,0,0,
]);

//second figure
const vertexData2 = new Float32Array([
    0.13, 0.13, 0,
    0.13, -0.13, 0,
    -0.13, -0.13, 0,
    -.13,.13,0,
]);

//Third Figure
const vertexData3 = new Float32Array([
    0.13, 0.13, 0,
    0.13, -0.13, 0,
    -0.13, -0.13, 0,
    -.13,.13,0,
]);

//First Figure
const buffer=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexData,gl.STATIC_DRAW);

//second figure
const buffer2 = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);
gl.bufferData(gl.ARRAY_BUFFER, vertexData2, gl.STATIC_DRAW);

//Third figure
const buffer3 = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer3);
gl.bufferData(gl.ARRAY_BUFFER, vertexData3, gl.STATIC_DRAW);


const vertexShader=gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader,`
attribute vec3 position;
uniform float rotation;
uniform vec2 translation;
void main(){
    vec2 rotatedPosition=vec2(position.x*cos(rotation)-position.y*sin(rotation), position.x*sin(rotation)+position.y*cos(rotation));
    gl_Position=vec4(rotatedPosition.x+translation.x, rotatedPosition.y+translation.y, position.z,1);
}
`);
gl.compileShader(vertexShader);

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader,`
void main(){
    gl_FragColor=vec4(1, 0, 0, 1);
}
`);
gl.compileShader(fragmentShader);

const fragmentShader2 = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader2,`
void main(){
    gl_FragColor = vec4(0, 1, 0, 1); // Green color
}
`);
gl.compileShader(fragmentShader2);

const fragmentShader3 = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader3,`
void main(){
    gl_FragColor = vec4(0, 0, 1, 1); // Green color
}
`);
gl.compileShader(fragmentShader3);

const program=gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

const program2 = gl.createProgram();
gl.attachShader(program2, vertexShader);
gl.attachShader(program2, fragmentShader2);
gl.linkProgram(program2);

const program3 = gl.createProgram();
gl.attachShader(program3, vertexShader);
gl.attachShader(program3, fragmentShader3);
gl.linkProgram(program3);

const positionLocation = gl.getAttribLocation(program, 'position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 3 , gl.FLOAT , false , 0 , 0);

const positionLocation2 = gl.getAttribLocation(program2, 'position');
gl.enableVertexAttribArray(positionLocation2);
gl.vertexAttribPointer(positionLocation2, 3 , gl.FLOAT , false , 0 , 0);

const positionLocation3 = gl.getAttribLocation(program, 'position');
gl.enableVertexAttribArray(positionLocation3);
gl.vertexAttribPointer(positionLocation3, 3 , gl.FLOAT , false , 0 , 0);

const rotatedLocation = gl.getUniformLocation(program, 'rotation');
const translationLocation = gl.getUniformLocation(program, 'translation');
const translationLocation2 = gl.getUniformLocation(program2, 'translation');
const translationLocation3 = gl.getUniformLocation(program3, 'translation');
const speed=0.050;
const speed2=0.060;
const speed3=0.10;


let rotation=0;
let x =-0.75;
let y =0;
let directionX=1;
let directionY=0;
let start=1;
let start1=1;
let start2=1;
let start3=1;

let x2 = 0;
let y2 = 0;
let directionX2 = 1;
let directionY2 = 0;

let x3 = 0.40;
let y3 = 0;
let directionX3 = 0;
let directionY3 = 1;

function animate(){
if(start==1){


    if(start1==1){
        // figure 1
        rotation +=0.30;
        x += directionX * speed;
        y += directionY * speed;
        if(x>=0.75 && directionX>0){
            directionX=0;
            directionY=1;
        }else if(y>=0.75 && directionY>0){
            directionX=-1;
            directionY=0;
        }else if(x<=-0.75 && directionX<0){
            directionX=0;
            directionY=-1;
        }else if(y<=-0.85 && directionY<0){
            directionX=1;
            directionY=0;
        }
        if (x < x3 + 0.13 && x + 0.13 > x3 && y < y3 + 0.13 && y + 0.13 > y3) {
            start *= -1;
            x3 = y3 = 1000;
        }
    }

    if(start2==1){
        //shake figure 2 in the x axis
        x2 += directionX2 * speed2;
        y2 += directionY2 * speed2;
        directionX2 *= -1;
    }
    
    

    if(start3==1){
        x3 += directionX3 * speed3;
        y3 += directionY3 * speed3;

        //figure 3
        if(y3>=0.75 &&  directionY3>0) {
            directionX3=0;
            directionY3=-1;
        }else if(y3<=-0.75 && directionY3<0){
            directionX3=0;
            directionY3=1;
        }
        if (x < x3 + 0.13 && x + 0.13 > x3 && y < y3 + 0.13 && y + 0.13 > y3) {
            start *= -1;
            x3 = y3 = 1000;
        }
    }

    // if the minor object hits the major object, the minor object disappears from the screen and the screen is paused
    if (x < x3 + 0.13 && x + 0.13 > x3 && y < y3 + 0.13 && y + 0.13 > y3) {
        start *= -1;
        x3 = y3 = 1000;
    }
}
    //Figure 1
    gl.useProgram(program);
    gl.uniform1f(rotatedLocation, rotation);
    gl.uniform2f(translationLocation , x , y );
    gl.drawArrays(gl.TRIANGLES,0,3);
    
    //Figure 2
    gl.useProgram(program2);
    gl.uniform2f(translationLocation2, x2 , y2 );
    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

    //Figure 3
    gl.useProgram(program3);
    gl.uniform2f(translationLocation3, x3 , y3 );
    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
    requestAnimationFrame(animate);
}
animate();

function st(){
    start*=-1;
}
function st_1(){
    start1*=-1;
}
function st_2(){
    start2*=-1;
}
function st_3(){
    start3*=-1;
}



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

CUBO A RODAR E COM CORES ALTENATIVAS, COM TRES BOTOES.


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <button id="button-switcher" onclick="bt()" class="button">Random color</button>
    <button id="button-switcher" onclick="bt_1()" class="button">X axis</button>
    <button id="button-switcher" onclick="bt_2()" class="button">Y axis</button>
    <button id="button-switcher" onclick="bt_3()" class="button">Z axis</button>
    <canvas 
    width= "600"
    height="400"
    style="background-color:rgb(25, 124, 75) ; border: 2px solid black;"></canvas>
    <script src="main.js"></script>
    
</body>
</html>



const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');
if (!gl){
    throw new Error ('webGL not supported');
}
const vertexData = new Float32Array([ 


    /*
    -0.5, -0.5, 0,
    0.5, -0.5, 0,
    0.0, 0.5, 0,
    */
    //FRONT

    0.25, 0.25, 0.25,
    0.25, -0.25, 0.25,
    -0.25, 0.25, 0.25,
    -0.25, 0.25, 0.25,
    0.25, -0.25, 0.25,
    -0.25, -0.25, 0.25,
    //LEFT
    -0.25, 0.25, 0.25,
    -0.25, -0.25, 0.25,
    -0.25, 0.25, -0.25,
    -0.25, 0.25, -0.25,
    -0.25, -0.25, 0.25,
    -0.25, -0.25, -0.25,
    //BACK
    -0.25, 0.25, -0.25,
    -0.25, -0.25, -0.25,
    0.25, 0.25, -0.25,
    0.25, 0.25, -0.25,
    -0.25, -0.25, -0.25,
    0.25, -0.25, -0.25,
    //RIGHT
    0.25, 0.25, -0.25,
    0.25, -0.25, -0.25,
    0.25, 0.25, 0.25,
    0.25, 0.25, 0.25,
    0.25, -0.25, 0.25,
    0.25, -0.25, -0.25,
    //TOP
    0.25, 0.25, 0.25,
    0.25, 0.25, -0.25,
    -0.25, 0.25, 0.25,
    -0.25, 0.25, 0.25,
    0.25, 0.25, -0.25,
    -0.25, 0.25, -0.25,
    //BOTTOM
    0.25, -0.25, 0.25,
    0.25, -0.25, -0.25,
    -0.25, -0.25, 0.25,
    -0.25, -0.25, 0.25,
    0.25, -0.25, -0.25,
    -0.25, -0.25, -0.25,
]);
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, `
attribute vec3 position;
uniform float rotateZ;
uniform float rotateX;
uniform float rotateY;
    void main(){
        vec2 rotatedPos=vec2((position.x*cos(rotateX)-position.y*sin(rotateX))*cos(rotateY), 
        (position.x*sin(rotateX)+position.y*cos(rotateX))*cos(rotateZ)-position.z*sin(rotateZ));
        gl_Position = vec4(rotatedPos.x, rotatedPos.y, position.z, 1);
        
    }`);
gl.compileShader(vertexShader);

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, `
precision mediump float;
uniform vec3 color;
void main() {
    gl_FragColor = vec4(color, 1);
}`);
gl.compileShader(fragmentShader);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

const positionLocation = gl.getAttribLocation(program, 'position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

const rotatexpos=gl.getUniformLocation(program, 'rotateX');
const rotateypos=gl.getUniformLocation(program, 'rotateY');
const rotatezpos=gl.getUniformLocation(program, 'rotateZ');
const colorP= gl.getUniformLocation(program, 'color');
let start=1;
let start2=1;
let start3=1;
let start4=1;
let R=1;
let G=1;
let B=1;
let rotation=0;
function animate(){
    rotation+=0.05;
    if(start==-1){
        gl.uniform3f(colorP, Math.random()*R, Math.random()*G, Math.random()*B);
    }
    if(start2==-1){
        gl.uniform1f(rotatexpos,rotation);
        gl.uniform1f(rotateypos,0);
        
    }
    if(start3==-1){
        gl.uniform1f(rotateypos,rotation);
        gl.uniform1f(rotatexpos,0);
        
    }
    if(start4==-1){
        gl.uniform1f(rotatezpos,rotation);
        
    }
    // para o cubo
    gl.drawArrays(gl.TRIANGLES, 0,vertexData.length/3);
// para o trianglo
    //gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(animate);
}
animate();
function bt(){
    start*=-1;
}
function bt_1(){
    start4*=-1;
}
function bt_2(){
    start3*=-1;
}
function bt_3(){
    start2*=-1;
}


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

CUBO E TRIANGLE RODANDO COM CORES E BOTOES, POR MARCOS.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="main.css">
    <title>Day 5 TRIANGLE/CUBE RANDOM COLOR</title>
</head>
<body>
    <h1>DAY 5 RIANGLE/CUBE RANDOM COLOR</h1>
    <button id="button-switcher" onclick="st_2()" class="button">X axis</button>
    <button id="button-switcher" onclick="st_3()" class="button">Y axis</button>
    <button id="button-switcher" onclick="st_4()" class="button">Z axis</button>
    <canvas width="600" height="400" style="background-color:rgb(240, 234, 234); border: 2px solid black;">
    </canvas>
    <script src="main.js"></script>
</body>
</html>


/////
button{
    border-style:groove;
    font-size: medium;
    background-color: darkblue;
}
body{
    background-color: brown;
}



///////

const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');
if (!gl) {
    throw new Error('WebGL not supported');
}

const vertexData = new Float32Array([
   //FRONT
   0.25, 0.25, 0.25,
   0.25, -0.25, 0.25,
   -0.25, 0.25, 0.25,
   -0.25, 0.25, 0.25,
   0.25, -0.25, 0.25,
   -0.25, -0.25, 0.25,
   //LEFT
   -0.25, 0.25, 0.25,
   -0.25, -0.25, 0.25,
   -0.25, 0.25, -0.25,
   -0.25, 0.25, -0.25,
   -0.25, -0.25, 0.25,
   -0.25, -0.25, -0.25,
   //BACK
   -0.25, 0.25, -0.25,
   -0.25, -0.25, -0.25,
   0.25, 0.25, -0.25,
   0.25, 0.25, -0.25,
   -0.25, -0.25, -0.25,
   0.25, -0.25, -0.25,
   //RIGHT
   0.25, 0.25, -0.25,
   0.25, -0.25, -0.25,
   0.25, 0.25, 0.25,
   0.25, 0.25, 0.25,
   0.25, -0.25, 0.25,
   0.25, -0.25, -0.25,
   //TOP
   0.25, 0.25, 0.25,
   0.25, 0.25, -0.25,
   -0.25, 0.25, 0.25,
   -0.25, 0.25, 0.25,
   0.25, 0.25, -0.25,
   -0.25, 0.25, -0.25,
   //BOTTOM
   0.25, -0.25, 0.25,
   0.25, -0.25, -0.25,
   -0.25, -0.25, 0.25,
   -0.25, -0.25, 0.25,
   0.25, -0.25, -0.25,
   -0.25, -0.25, -0.25,
]);


function randomColor() {
    return [Math.random(), Math.random(), Math.random()];
}

let colorData = [];
for (let face = 0; face < 6; face++) {
    let faceColor = randomColor();
    for (let vertex = 0; vertex < 6; vertex++) {
        colorData.push(...faceColor);
    }
}

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

const colorBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorData), gl.STATIC_DRAW);

const vertexShaderSource = `
    precision mediump float;
    attribute vec3 pos;
    attribute vec3 color;
    varying vec3 vColor;
    uniform float rotate;
    uniform float rotateX;
    uniform float rotateY;
    uniform float rotateZ;
    void main(){
        vColor = color;
        mat3 rotationMatrix = mat3(
            cos(rotateY) * cos(rotateZ), -cos(rotateY) * sin(rotateZ), sin(rotateY),
            cos(rotateX) * sin(rotateZ) + sin(rotateX) * sin(rotateY) * cos(rotateZ), cos(rotateX) * cos(rotateZ) - sin(rotateX) * sin(rotateY) * sin(rotateZ), -sin(rotateX) * cos(rotateY),
            sin(rotateX) * sin(rotateZ) - cos(rotateX) * sin(rotateY) * cos(rotateZ), sin(rotateX) * cos(rotateZ) + cos(rotateX) * sin(rotateY) * sin(rotateZ), cos(rotateX) * cos(rotateY)
        );
        vec3 rotatedPos = rotationMatrix * pos;
        gl_Position = vec4(rotatedPos, 1.0);
    }
`;

const fragmentShaderSource = `
    precision mediump float;
    varying vec3 vColor;
    void main(){
        gl_FragColor = vec4(vColor, 1);
    }
`;

function compileShader(source, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }

    return shader;
}

const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

const posLocation = gl.getAttribLocation(program, 'pos');
const colorLocation = gl.getAttribLocation(program, 'color');
const rotateXpos = gl.getUniformLocation(program, 'rotateX');
const rotateYpos = gl.getUniformLocation(program, 'rotateY');
const rotateZpos = gl.getUniformLocation(program, 'rotateZ');

gl.enableVertexAttribArray(posLocation);
gl.enableVertexAttribArray(colorLocation);

gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.vertexAttribPointer(posLocation, 3, gl.FLOAT, false, 0, 0);

gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);

let rotation = 0;
let start4 = 1;
let start5 = 1;
let start6 = 1;

gl.enable(gl.DEPTH_TEST);

function animate() {
    rotation += 0.025;
    if (start6 == -1) {
        gl.uniform1f(rotateXpos, rotation);
    }
    if (start5 == -1) {
        gl.uniform1f(rotateYpos, rotation);
    }
    if (start4 == -1) {
        gl.uniform1f(rotateZpos, rotation);
    }
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.drawArrays(gl.TRIANGLES, 0, vertexData.length / 3);
    requestAnimationFrame(animate);
}

animate();

function st() {
    start *= -1;
}

function st_2() {
    start6 *= -1;
}

function st_3() {
    
    start5 *= -1;
}

function st_4() {
    start4 *= -1;
}

/*
const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');
if (!gl) {
    throw new Error('WebGL not supported');
}

const vertexData = new Float32Array([0, 0.25, 0, 0.25, 0, 0, -0.25, 0, 0]);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, `
    attribute vec3 pos;
     
    void main(){
        gl_Position = vec4(pos, 1.0);
    }
`);
gl.compileShader(vertexShader);

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, `
    precision mediump float;

    uniform vec3 color;
    void main(){
        gl_FragColor = vec4(color, 1);
    }
`);
gl.compileShader(fragmentShader);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

const posLocation = gl.getAttribLocation(program, 'pos');
gl.enableVertexAttribArray(posLocation);
gl.vertexAttribPointer(posLocation, 3, gl.FLOAT, false, 0, 0);

const colorP = gl.getUniformLocation(program, 'color');

gl.useProgram(program);

let start=1;
let R=1;
let G=1;
let B=1;

function animate(){
    if(start==-1){
        gl.uniform3f(colorP, Math.random(R),Math.random(G),Math.random(B));
    }
    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(animate);
}
animate();

function st(){
    start*=-1;
}
*/



/*CODE 2 OF DAY 5
const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');
if (!gl) {
    throw new Error('WebGL not supported');
}

const vertexData = new Float32Array([
    //FRONT
    0.25, 0.25, 0.25,
    0.25, -0.25, 0.25,
    -0.25, 0.25, 0.25,
    -0.25, 0.25, 0.25,
    0.25, -0.25, 0.25,
    -0.25, -0.25, 0.25,
    //LEFT
    -0.25, 0.25, 0.25,
    -0.25, -0.25, 0.25,
    -0.25, 0.25, -0.25,
    -0.25, 0.25, -0.25,
    -0.25, -0.25, 0.25,
    -0.25, -0.25, -0.25,
    //BACK
    -0.25, 0.25, -0.25,
    -0.25, -0.25, -0.25,
    0.25, 0.25, -0.25,
    0.25, 0.25, -0.25,
    -0.25, -0.25, -0.25,
    0.25, -0.25, -0.25,
    //RIGHT
    0.25, 0.25, -0.25,
    0.25, -0.25, -0.25,
    0.25, 0.25, 0.25,
    0.25, 0.25, 0.25,
    0.25, -0.25, 0.25,
    0.25, -0.25, -0.25,
    //TOP
    0.25, 0.25, 0.25,
    0.25, 0.25, -0.25,
    -0.25, 0.25, 0.25,
    -0.25, 0.25, 0.25,
    0.25, 0.25, -0.25,
    -0.25, 0.25, -0.25,
    //BOTTOM
    0.25, -0.25, 0.25,
    0.25, -0.25, -0.25,
    -0.25, -0.25, 0.25,
    -0.25, -0.25, 0.25,
    0.25, -0.25, -0.25,
    -0.25, -0.25, -0.25,
]);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, `
    attribute vec3 pos;
    uniform vec2 translation;
    uniform float rotate;
    uniform float rotateX;
    uniform float rotateY;
    void main(){
        vec2 rotatedPos = vec2(
            (pos.x * cos(rotateX) - pos.y * sin(rotateX)) * cos(rotateY),
            (pos.y * cos(rotateX) + pos.x * sin(rotateX)) * cos(rotate) - pos.z * sin(rotate)
        );
        gl_Position = vec4(rotatedPos.x, rotatedPos.y, pos.z, 1.0);
    }
`);
gl.compileShader(vertexShader);

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, `
    precision mediump float;
    uniform vec3 color;
    void main(){
        gl_FragColor = vec4(color, 1);
    }
`);
gl.compileShader(fragmentShader);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

const posLocation = gl.getAttribLocation(program, 'pos');
gl.enableVertexAttribArray(posLocation);
gl.vertexAttribPointer(posLocation, 3, gl.FLOAT, false, 0, 0);

const rotateXpos = gl.getUniformLocation(program, 'rotateX');
const rotateYpos = gl.getUniformLocation(program, 'rotateY');
const rotatepos = gl.getUniformLocation(program, 'rotate');

const colorP = gl.getUniformLocation(program, 'color');

let rotation=0;
let start = 1;
let start4 = 1;
let start5 = 1;
let start6 = 1;
let R = 1;
let G = 1;
let B = 1;

function animate() {
    rotation+=0.025;
    if (start == -1) {
        gl.uniform3f(colorP, Math.random() * R, Math.random() * G, Math.random() * B);
    }
    if (start4 == -1) {
        gl.uniform1f(rotateXpos, rotation);
        //gl.uniform1f(rotateYpos, 0);
        }
    if (start5 == -1) {
        gl.uniform1f(rotateYpos, rotation);
        //gl.uniform1f(rotateXpos, 0);
    }
    if (start6 == -1) {
        gl.uniform1f(rotatepos, rotation);
    }
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, vertexData.length / 3);
    requestAnimationFrame(animate);
}

animate();

function st() {
    start *= -1;
}

function st_2() {
    start6 *= -1;
}

function st_3() {
    
    start5 *= -1;
}

function st_4() {
    start4 *= -1;
}
*/




>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

TRIANGLE WITH THREE COLORS


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRIANGLE WITH THREE COLORS</title>
</head>
<body>
    <canvas height="400" width="700" style="background-color: aliceblue; border: 2px solid black;"></canvas>
    <script src="main.js"></script>
</body>
</html>



//////////


const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');

if (!gl) {
    throw new Error('WebGL not supported');
}

const vertexData=new Float32Array([
    0, 0.5, 0,    // V1.position
    .5, 0, 0,   // V2.position
    -.5,0,0,

]);

const colorData=new Float32Array([
    1,0,0,
    0,1,0,
    0,0,1,
]);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

const colorBuffer=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,colorBuffer);
gl.bufferData(gl.ARRAY_BUFFER,colorData , gl.DYNAMIC_DRAW);

const vertexShader=gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader,`
precision mediump float;

attribute vec3 pos;
attribute vec3 color;
varying vec3 vColor;

void main(){
    vColor=color;
    gl_Position=vec4(pos,2);
}
`);
gl.compileShader(vertexShader);

const fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader,`
precision mediump float;
varying vec3 vColor;
void main(){
gl_FragColor=vec4(vColor,1);

}
`);
gl.compileShader(fragmentShader);

const program=gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

const posLocation=gl.getAttribLocation(program,'pos');
gl.enableVertexAttribArray(posLocation);
gl.vertexAttribPointer(posLocation, 3, gl.FLOAT, false, 0,0);

const colorLocation=gl.getAttribLocation(program,'color');
gl.enableVertexAttribArray(colorLocation);
gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0,0);

gl.useProgram(program);
gl.drawArrays(gl.TRIANGLES, 0, 3);




















